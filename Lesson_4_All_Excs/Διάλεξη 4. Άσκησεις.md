Διάλεξη 4. Άσκηση 1



α) Ο κώδικας αντικαθιστα την τιμή 3 με την τιμή 5 σε όλο το μήκος του πίνακα. Άρα τελικά:



int arr\[] = \[3,4,3,3,2]



β) Αριθμός πράξεων:

&nbsp;	

&nbsp;	Αρχική ανάθεση i=0 - 1 Πράξη 

&nbsp;	i<n - 1 πράξη x 5 φορές μεσα στο loop + 1 τελική σύγκριση για να τελειώσει το loop. Σύνολο 6.

&nbsp;	arr\[i} = key - 1 πράξη x 5 φορές μεσα στο loop. Σύνολο 5

&nbsp;	Αν arr\[i] = key - 1 πράξη. Στην περίπτωση μας η συνθήκη ικανοποιείται τρεις φορές, άρα σύνολο 3 πράξεις. 

&nbsp;	i++ - 1 πράξη x 5 φορές. Σύνολο 5.





Σύνολο: 20 πράξεις.





γ) Γίνεται σταθερός αριθμός πράξεων σε κάθε επαναληψη , άρα η πολυπλοκότητα αυξάνεται γραμμικά καθώς μεγαλώνει ο πίνακας. Άρα χειρότερη πολυπλοκότητα είναι O(n).

&nbsp;	





Άσκηση 2.



Η πολυπλοότητα θα είναι της μορφής Ο(n**^**2), επειδή έχουμε εμφωλιασμένο for. Από εκεί και πέρα, ο αριθμός των επαναλήψεων αλλάζει γραμμικά όσο μεγαλώνουν τα inputs, οπότε σε κάθε περίπτωση καλύτερη πολυπλοκότητα= χειρότερη= μεση= Ο(n^2).

&nbsp;



Άσκηση 3



Παρατηρούμε ότι για n=2 :



Α= 2x2 -2x2 +1= 1

B=8 - 4x2= 0.



Άρα Β<Α , και άρα καλύτερος. Από n=3 και όσο το n αυξάνεται, ο Β θα έχει σταθερά υψηλότερη πολυπλοκότητα, άρα η μόνη τιμή οπου ο Β είναι καλύτερος τοy A είναι για n=2.



Για πολύ μεγάλο n αντίστοιχα. το τετράγωνο είναι πολύ μικρότερο του κύβου, άρα επιλέγουμε τον A.

